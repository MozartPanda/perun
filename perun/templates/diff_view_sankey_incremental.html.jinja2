{% import 'macros_profile_overview.html.jinja2' as profile_overview %}
{% import 'macros_html_widgets.html.jinja2' as widgets %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/2.0.3/css/dataTables.dataTables.min.css">
    <script type="text/javascript" charset="utf8" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src='https://cdn.plot.ly/plotly-2.30.0.min.js'></script>
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/2.0.3/js/dataTables.min.js"></script>
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/select/2.0.0/js/dataTables.select.min.js"></script>
    <style>
        html {
            font-family: "Courier New", Courier, monospace;
        }
        .column {
            width: 48%;
            margin: 0 1%;
        }
        .left {
            float: left;
        }
        .right {
            float: right;
        }
        .middle {
            width: 98%;
            float: left;
            margin: 0 1%;
            justify-content: center;
        }
        .column-head {
            border-bottom: 1px solid #ddd;
            border-top: 1px solid #ddd;
            text-align: center;
        }

        div.tools table {
            border-collapse: collapse;
            border-bottom: 1px solid #ddd;
            margin: 0 auto 0 auto;
        }

        div.tools td.value {
            padding: 1em 0.5em;
            text-align: left;
        }

        div.tools td.key {
            padding: 1em 0.5em;
            text-align: right;
            font-weight: bold;
        }
        div.tools td.check_option {
            padding: 1em 0.5em;
        }
        div.tools td.topkey {
            padding: 1em 0 0;
            text-align: center;
            font-weight: bold;
        }
        {{ profile_overview.css_style() }}
        {{ widgets.range_picker_style() }}

        #label_base {
            border-bottom: 5px solid {{ palette.Baseline }};
        }
        #label_target {
            border-bottom: 5px solid {{ palette.Target }};
        }
        #label_incr {
            border-bottom: 5px solid {{ palette.NotInBaseline }};
        }
        #label_both {
            border-bottom: 5px solid {{ palette.InBoth }};
        }
        #label_decr {
            border-bottom: 5px solid {{ palette.NotInTarget }};
        }
    </style>
</head>
<body>

<div class="left column">
    <h2 class="column-head">{{ lhs_tag }}</h2>
    {{ profile_overview.overview_table('toggleLeftCollapse', 'left-info', lhs_header, rhs_header) }}
    <div style="margin: 0 10px;">&nbsp;</div>
</div>

<div class="right column">
    <h2 class="column-head">{{ rhs_tag }}</h2>
    {{ profile_overview.overview_table('toggleRightCollapse', 'right-info', rhs_header, lhs_header) }}
    <div style="margin: 0 10px;">&nbsp;</div>
</div>

<div class="middle">
    <div class="tools">
        <table id="table" class="display" style="width: 100%;">
            <thead>
            <tr>
                <th>Unit</th>
                <th>Absolute</th>
                <th>Relative</th>
            </tr>
            </thead>
        </table>
        <table>
            <tbody>
                <tr>
                    <td class="key" style="width: 20%;">Threshold:</td>
                    <td colspan="6">{{ widgets.range_picker() }}</td>
                </tr>
                {{ widgets.checkboxes([('base', 'Baseline'), ('target', 'Target'), ('incr', 'Incr (vs base)'), ('both', 'Equal'), ('decr', 'Decr (vs base)')], 'show_edges', 'Show') }}
                <tr>
                    <td class="key" style="width: 20%;">Metric:</td>
                    <td colspan="6">
                        <select class="dt-input", id="metricSelection">
                            {%- for metric in stat_list %}
                                <option value="{{ loop.index0 }}">{{ metric }}</option>
                            {% endfor %}
                        </select>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

   <div id="sankey_graph"><!-- DO NOT CHANGE: SANKEY GRAPH IS RENDERED HERE--></div>
</div>

<script>
    let sankey_data = [{
        type: "sankey",
        arrangement: "fixed",
        orientation: "v",
        node: {
            pad: 15,
            thickness: 20,
            line: {
                color: "black",
                width: 1
            },
            label: [],
            color: [],
            customdata: []
        },
        link: {
            source: [],
            target: [],
            value: [],
            color: [],
            customdata: []
        }
        }],
        shown_nodes = [],
        steps = [1],
        layout = {
            title: "",
            font: {
                size: 14
            },
            height: 600,
        },
        selected_metric = 0;
        number_of_metrics = {{ stat_list|length }};
        selected_uid = -1,
        selected_uid_text = "",
        plot = document.getElementById('sankey_graph');

    // Selection table
    let table = {
        "data": [
            {% for val in selection_table %}
                {
                    "uid": "{{ val.uid }}",
                    "index": "{{ val.index }}",
                    "abs": "{{ val.abs_amount }}",
                    "rel": "{{ val.rel_amount }}"
                },
            {%- endfor %}
        ]
    };
    let selection_table = $("#table").DataTable({
        data: table.data,
        columns: [
            { data: "uid" },
            {
                data: "abs",
                className: "dt-body-right",
                render: function (data, type) {
                    if (type === 'display') {
                        const floatValue = parseFloat(data);
                        const intValue = parseInt(data);
                        if (!isNaN(intValue) && intValue.toString() === data) {
                            let formatted_int= intValue.toLocaleString();
                            return `${formatted_int}`;
                        } else if(!isNaN(floatValue) && floatValue.toString() === data) {
                            let formatted_float = floatValue.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                            return `${formatted_float}`;
                        } else {
                            return data;
                        }
                    }

                    return data;
                },
            },
            { data: "rel" },
            { data: "index", visible: false},
        ],
        order: [[2, "desc"]],
        iDisplayLength: 5,
        select: true
    })

    // Graph data
    {% autoescape off %}
    let caller_graph = {{ caller_graph }}
    let callee_graph = {{ callee_graph }}
    let nodes = {{ nodes }}
    let stats = {{ stats }}
    let node_map = {{ node_map }}
    {% endautoescape %}

    {{ profile_overview.toggle_script('toggleLeftCollapse', 'left-info') }}
    {{ profile_overview.toggle_script('toggleRightCollapse', 'right-info') }}

    {{ widgets.checkbox_handler() }}
    {{ widgets.range_handlers() }}

    function render() {
        Plotly.react('sankey_graph', sankey_data, layout);
    }

    function newplot() {
        Plotly.newPlot('sankey_graph', sankey_data, layout, {responsive: true});
        refreshHandlers();
    }

    function refreshHandlers() {
        plot.on('plotly_afterplot', function () {
            //annotateEdges();
        });
        plot.on('plotly_click', function (idata) {
            for (let i = 0; i < idata.points.length; i++) {
                clicked = idata.points[i];
                if (clicked.customdata !== undefined) {
                    clickedNode = getNode(clicked.customdata.index, clicked.customdata.pos, false);
                    if (clicked.customdata.hidden) {
                        addAllEdgesFor(clickedNode, clicked.customdata.pos, callee_graph[clicked.customdata.index][clicked.customdata.pos], false);
                        addAllEdgesFor(clickedNode, clicked.customdata.pos, caller_graph[clicked.customdata.index][clicked.customdata.pos], true);
                        sankey_data[0].node.label[clicked.customdata.id] = clicked.customdata.label;
                        clicked.customdata.hidden = false;
                    }
                }
            }
            render();
        })
    }

    function filterEdges() {
        edges = sankey_data[0].link;
        let fromInput = document.getElementById('fromSlider').value;
        let toInput = document.getElementById('toSlider').value;
        for (let i = 0; i < edges.customdata.length; i++) {
            newValue = recomputeValue(edges.customdata[i].type, edges.customdata[i].stats);
            edges.value[i] = (fromInput <= newValue && newValue <= toInput) ? newValue : 0;
        }
        render();
    }

    // Graph Operations
    function getNode(node, pos, isroot) {
        node_len = shown_nodes.length;

        for (let i = 0; i < node_len; i++) {
            if (shown_nodes[i][0] === node && shown_nodes[i][1] === pos) {
                return i;
            }
        }

        if (isroot) {
            sankey_data[0].node.color.push("rgba(0, 0, 0, 0.7)");
            sankey_data[0].node.label.push(nodes[node]);
            sankey_data[0].node.customdata.push({label: nodes[node], index: node, pos: pos, hidden: false, root: true, id: node_len});
        } else {
            sankey_data[0].node.color.push("rgba(0, 0, 0, 0.2)");
            sankey_data[0].node.label.push("[+]");
            sankey_data[0].node.customdata.push({label: nodes[node], index: node, pos: pos, hidden: true, root: false, id: node_len});
        }
        shown_nodes.push([node, pos])
        return node_len;
    }

    function clearGraph() {
        sankey_data[0].node.label = [];
        sankey_data[0].node.color = [];
        sankey_data[0].node.customdata = [];
        sankey_data[0].link.source = [];
        sankey_data[0].link.target = [];
        sankey_data[0].link.value = [];
        sankey_data[0].link.color = [];
        sankey_data[0].link.customdata = [];
        shown_nodes = [];
        steps = [];
    }

    function fillSliders(fromMin, fromVal, fromMax, toMin, toVal, toMax) {
        let fromSlider = document.getElementById('fromSlider');
        let toSlider = document.getElementById('toSlider');

        fromSlider.min = fromMin;
        fromSlider.value = fromVal;
        fromSlider.max = fromMax;
        toSlider.min = toMin;
        toSlider.value = toVal;
        toSlider.max = toMax;

        setInput(fromInput, fromVal);
        setInput(toInput, toVal);

        fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
    }

    function updateSliders(val) {
        if (val == 0 || val == 0.0) {
            return;
        }

        let fromSlider = document.getElementById('fromSlider');
        let toSlider = document.getElementById('toSlider');

        let minVal = Math.min(fromSlider.min, val);
        let maxVal = Math.max(toSlider.max, val);


        if (fromSlider.value !== fromSlider.min) {
            minVal = fromSlider.value
        }
        if (toSlider.value !== toSlider.max) {
            maxVal = toSlider.value
        }

        if (steps.length === 1) {
            fillSliders(val, val, val, val, val, val);
        } else {
            fillSliders(Math.min(fromSlider.min, val), minVal, Math.max(fromSlider.max, val), Math.min(toSlider.min, val), maxVal, Math.max(toSlider.max, val));
        }
    }

    function addToSteps(val) {
        let low = 0, high = steps.length - 1;

        while (low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (steps[mid] === val) {
                return;
            } else if(steps[mid] < val) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        steps.splice(low, 0, val);
        updateSliders(val);
    }

    function addToSankey(src, target, val, color, type, edge_stats) {
        sankey_data[0].link.source.push(src);
        sankey_data[0].link.target.push(target);
        sankey_data[0].link.value.push(val);
        sankey_data[0].link.color.push(color);
        sankey_data[0].link.customdata.push({stats: edge_stats, type: type})
        addToSteps(val);
    }

    function recomputeValue(stat_type, edge_stats) {
        if (!isChecked(stat_type))
            return 0;

        // Baseline data
        let baseline_stat = edge_stats[selected_metric], target_stat = edge_stats[selected_metric+number_of_metrics];
        if (stat_type === "baseline")
            return baseline_stat;
        if (stat_type === "target")
            return target_stat;
        let diff = baseline_stat - target_stat;
        if (stat_type === "decr")
            return diff > 0 ? Math.abs(diff) : 0;
        if (stat_type === "incr")
            return diff <= 0 ? Math.abs(diff) : 0;
        if (stat_type === "both")
            return Math.min(baseline_stat, target_stat);
    }

    function addEdge(src, target, edge_stats) {
        // Baseline data
        let baseline_stat = edge_stats[selected_metric], target_stat = edge_stats[selected_metric+number_of_metrics];
        if (baseline_stat) {
            addToSankey(src, target, baseline_stat, "rgba(49, 48, 77, 0.4)", "baseline", edge_stats)
        }
        if (target_stat) {
            addToSankey(src, target, target_stat, "rgba(255, 201, 74, 0.4)", "target", edge_stats)
        }
        let diff = baseline_stat - target_stat;
        if (diff > 0) {
            // Baseline is higher
            addToSankey(src, target, diff, "rgba(0, 250, 0, 0.4)", "decr", edge_stats);
            addToSankey(src, target, 0, "rgba(255, 0, 0, 0.4)", "incr", edge_stats);
            addToSankey(src, target, Math.min(baseline_stat, target_stat), "rgba(0, 0, 255, 0.4)", "both", edge_stats);
        } else {
            addToSankey(src, target, Math.abs(diff), "rgba(250, 0, 0, 0.4)", "incr", edge_stats);
            addToSankey(src, target, 0, "rgba(0, 250, 0, 0.4)", "decr", edge_stats);
            addToSankey(src, target, Math.min(baseline_stat, target_stat), "rgba(0, 0, 255, 0.4)", "both", edge_stats);
        }
    }

    function addAllEdgesFor(node, pos, edges, isfwd) {
        if (edges !== undefined) {
            for (edge in edges) {
                if (isfwd) {
                    addEdge(node, getNode(edge, pos-1, false), stats[edges[edge]]);
                } else {
                    addEdge(getNode(edge, pos-1, false), node, stats[edges[edge]]);
                }
            }
        }
    }

    function addRootNode(index) {
        // Add node to labels
        for (let i = 0; i < node_map[index].length; i++) {
            pos = node_map[index][i];
            rootNode = getNode(index, pos, true);
            addAllEdgesFor(rootNode, pos, callee_graph[index][pos], false);
            addAllEdgesFor(rootNode, pos, caller_graph[index][pos], true);
        }
    }

    // Event handlers
    selection_table.on('click', 'tbody tr', (el) => {
        let classList = el.currentTarget.classList;

        if (classList.contains('selected')) {
            classList.remove('selected');
        } else {
            selection_table.rows('.selected').nodes().each((row) => row.classList.remove('selected'));
            classList.add('selected');
        }
    })

    selection_table.on('select', function(e, dt, type, indexes) {
        if (type === 'row') {
            let data = selection_table.rows(indexes).data();
            if (data.length > 0) {
                selected_uid = data[0].index;
                selected_uid_text = data[0].uid;
                layout.title = selected_uid_text;
                clearGraph();
                addRootNode(selected_uid);
                newplot();
                fillSliders(steps[0], steps[0], steps[steps.length-1], steps[0], steps[steps.length-1], steps[steps.length-1]);
                filterEdges();
            }
        }
    })

    document.getElementById("metricSelection").addEventListener('change', function() {
        selected_metric = parseInt(document.getElementById("metricSelection").value);
        let values = [];
        let edge_values = sankey_data[0].link.customdata;
        for (let i = 0; i < edge_values.length; i++) {
            baseline_metric = edge_values[i].stats[selected_metric];
            target_metric = edge_values[i].stats[selected_metric+number_of_metrics]
            // We skip empty metrics
            if (baseline_metric !== 0)
                values.push(baseline_metric);
            if (target_metric !== 0)
                values.push(target_metric);
        }

        // We adjust empty values
        if (values.length === 0) {
            steps = [0];
        } else {
            steps = Array.from(new Set(values)).sort((a, b) => a - b);
        }

        fillSliders(steps[0], steps[0], steps[steps.length-1], steps[0], steps[steps.length-1], steps[steps.length-1]);
        filterEdges();
    });

    document.querySelector('input[name="incr"]').addEventListener('change', filterEdges);
    document.querySelector('input[name="decr"]').addEventListener('change', filterEdges);
    document.querySelector('input[name="both"]').addEventListener('change', filterEdges);
    document.querySelector('input[name="base"]').addEventListener('change', filterEdges);
    document.querySelector('input[name="base"]').checked = false;
    document.querySelector('input[name="target"]').addEventListener('change', filterEdges);
    document.querySelector('input[name="target"]').checked = false;

    document.querySelector('#fromSlider').addEventListener('change', filterEdges);
    document.querySelector('#toSlider').addEventListener('change', filterEdges);

    newplot()
</script>

</body>
</html>
